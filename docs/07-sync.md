```markdown
# 07 - Продвинутая Синхронизация Данных (WiseJSON Sync)

WiseJSON DB предлагает мощную и надежную систему двусторонней синхронизации данных между локальной базой и удаленным сервером. Эта система спроектирована с упором на отказоустойчивость, предсказуемость и прозрачность для разработчика.

## Ключевые Принципы и Возможности

*   **PULL -> PUSH Модель**: Для уменьшения количества конфликтов, клиент сначала запрашивает и применяет изменения с сервера (`PULL`), и только потом отправляет свои локальные изменения (`PUSH`).
*   **Токенизация (LSN)**: Вместо ненадежных временных меток клиента, синхронизация использует серверный **LSN** (Log Sequence Number) — монотонно возрастающий номер последней операции. Это гарантирует, что клиент получит все изменения и ничего не пропустит, независимо от настроек времени.
*   **Идемпотентность PUSH**: Каждая порция (батч) локальных изменений отправляется с уникальным ID (`batchId`). Сервер отслеживает полученные ID и игнорирует дубликаты, что защищает от повторного применения данных при сбоях сети.
*   **Пакетная отправка (Batching)**: Большое количество локальных изменений автоматически разбивается на небольшие пакеты для отправки, что предотвращает ошибки, связанные с большими телами запросов.
*   **Адаптивный интервал**: `SyncManager` автоматически регулирует частоту синхронизации. В периоды бездействия интервал увеличивается, а при активной работе — уменьшается, что снижает нагрузку на сеть.
*   **Механизм "Карантина"**: Если с сервера приходит "битая" операция, которую невозможно применить (например, из-за нарушения уникального индекса), она не останавливает всю синхронизацию, а помещается в специальный лог-файл `quarantine_<collection>.log` для последующего анализа.
*   **Heartbeat (Сердцебиение)**: Для проверки "живости" соединения в периоды бездействия `SyncManager` периодически отправляет легкие health-чеки на сервер.
*   **Прозрачная обработка ошибок**: Все ошибки синхронизации (сетевые, серверные) не "роняют" приложение, а генерируют событие `sync:error`, на которое можно подписаться.

## Как использовать

### Шаг 1: Подключение и настройка

Включить синхронизацию для коллекции можно с помощью метода `collection.enableSync()`.

```javascript
const WiseJSON = require('wise-json-db');
// Важно: apiClient импортируется из корневого модуля, а не из wise-json/sync
const { apiClient: ApiClient } = require('wise-json-db');
const path = require('path');

async function setupSync() {
    // 1. Инициализируем БД и коллекцию
    const db = new WiseJSON(path.resolve(__dirname, 'my-sync-db'));
    await db.init();
    const articles = await db.collection('articles');
    await articles.initPromise;

    // 2. Создаем экземпляр API-клиента
    const apiClientInstance = new ApiClient(
        'https://api.example.com', // Базовый URL вашего сервера
        'YOUR-SECRET-API-KEY'      // Ваш ключ API
    );

    // 3. Включаем синхронизацию, передавая клиент и другие опции
    articles.enableSync({
        apiClient: apiClientInstance,
        // Эти параметры обязательны для внутренней проверки, даже если передан apiClient
        url: 'https://api.example.com', 
        apiKey: 'YOUR-SECRET-API-KEY',

        // Необязательные параметры для тонкой настройки
        minSyncIntervalMs: 10000,     // мин. интервал (10 сек)
        maxSyncIntervalMs: 300000,    // макс. интервал (5 мин)
        pushBatchSize: 200,           // отправлять по 200 операций за раз
    });
}
```

### Шаг 2: Обработка событий синхронизации

Это самый важный шаг для создания надежного приложения. Подпишитесь на события, чтобы понимать, что происходит с синхронизацией.

```javascript
// Подписываемся на события ДО начала активной работы с коллекцией

// Успешное завершение полного цикла PULL -> PUSH
articles.on('sync:success', (payload) => {
  console.log(`[SYNC] Цикл завершен. Активность: ${payload.activityDetected}. LSN сервера: ${payload.lsn}`);
});

// Критическая ошибка в цикле синхронизации
articles.on('sync:error', (errorPayload) => {
  console.error(`[SYNC ERROR] ${errorPayload.message}`, errorPayload.originalError);
  // Здесь можно показать уведомление пользователю или записать в систему мониторинга
});

// Операция с сервера помещена в карантин
articles.on('sync:quarantine', (quarantinePayload) => {
  console.warn('[SYNC QUARANTINE] Не удалось применить операцию:', quarantinePayload.operation);
  console.warn('Причина:', quarantinePayload.error.message);
});

// Другие полезные события для отладки:
articles.on('sync:initial_start', () => console.log('[SYNC] Начальная полная синхронизация...'));
articles.on('sync:initial_complete', (p) => console.log(`[SYNC] Начальная синхронизация завершена. Загружено: ${p.documentsLoaded} док.`));
articles.on('sync:push_success', (p) => console.log(`[SYNC] Успешно отправлен батч ${p.batchId} (${p.pushed} операций).`));
articles.on('sync:pull_success', (p) => console.log(`[SYNC] Получено ${p.pulled} операций с сервера.`));
```
### Шаг 3: Работа с данными и ручное управление

После включения синхронизации просто работайте с коллекцией как обычно. Все изменения (`insert`, `update`, `remove`) будут автоматически поставлены в очередь на отправку.

```javascript
// Это изменение будет автоматически отправлено на сервер в следующем цикле sync
await articles.insert({ title: 'Новая статья', content: '...' });

// Вы можете принудительно запустить цикл синхронизации в любой момент
await articles.triggerSync();

// Получить текущий статус синхронизации
const status = articles.getSyncStatus();
console.log(status); // { state: 'idle', isSyncing: false, ... }

// Отключить синхронизацию (например, при выходе пользователя)
articles.disableSync();
```
## Требования к серверному API

Чтобы WiseJSON Sync работал корректно, ваш бэкенд должен реализовывать следующие эндпоинты:

### GET /sync/snapshot

*   **Назначение:** Для начальной полной синхронизации.
*   **Ответ:**
    ```json
    {
      "server_lsn": 12345,
      "documents": [
        { "_id": "...", "title": "...", "createdAt": "...", "updatedAt": "..." },
        // ...
      ]
    }
    ```

### GET /sync/pull?since_lsn=\<number>

*   **Назначение:** Получить дельту (новые операции) с сервера.
*   **Параметр:** `since_lsn` — последний LSN, известный клиенту. Сервер должен вернуть все операции с LSN > `since_lsn`.
*   **Ответ:**
    ```json
    {
      "server_lsn": 12350,
      "ops": [
        { "op": "INSERT", "doc": { "_id": "doc1", "data": "..." } },
        { "op": "UPDATE", "id": "doc2", "data": { "status": "done" } }
      ]
    }
    ```

### POST /sync/push

*   **Назначение:** Принять батч операций от клиента.
*   **Тело запроса:**
    ```json
    {
      "batchId": "уникальный-id-батча-uuid",
      "ops": [ /* массив операций из WAL клиента */ ]
    }
    ```
*   **Логика:** Сервер **ДОЛЖЕН** проверять `batchId` на уникальность. Если батч с таким ID уже был обработан, сервер должен вернуть успешный ответ, но не применять операции повторно (идемпотентность).
*   **Ответ:**
    ```json
    {
      "status": "ok",
      "server_lsn": 12355
    }
    ```
### GET /sync/health

*   **Назначение:** Проверка доступности сервера.
*   **Ответ:**
    ```json
    {
      "status": "ok"
    }
    ```

С этой продвинутой системой синхронизации вы можете создавать надежные оффлайн-приложения или распределенные системы с центральным сервером, будучи уверенными в целостности и сохранности данных.