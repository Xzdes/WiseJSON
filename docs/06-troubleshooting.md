```markdown
docs/06-troubleshooting.md
# 06 - Диагностика и Решение Проблем (FAQ)

В этом разделе собраны ответы на часто задаваемые вопросы и способы решения распространенных проблем, с которыми вы можете столкнуться при работе с WiseJSON DB.

### Q1: Мои данные не сохраняются после перезапуска приложения. Что делать?

**A1:** Наиболее вероятная причина — вы не закрываете базу данных должным образом перед завершением работы приложения. WiseJSON DB выполняет финальное сохранение данных (включая запись чекпоинтов и компакцию WAL) при вызове метода `await db.close()`.

*   **Решение:** Убедитесь, что в вашем коде есть блок `finally` или обработчик завершения процесса, который вызывает `await db.close()`.

    ```javascript
    let db;
    try {
      db = new WiseJSON(dbPath);
      await db.init();
      // ... ваша работа с БД ...
    } catch (error) {
      console.error(error);
    } finally {
      if (db) {
        await db.close(); // Обязательный вызов!
      }
    }
    ```

*   WiseJSON DB пытается автоматически сохраниться при получении сигналов `SIGINT` и `SIGTERM`, но это не всегда надежно, особенно при аварийном завершении. Явный вызов `db.close()` — лучшая практика.

### Q2: Я получаю ошибку `Duplicate value '...' for unique index '...'`. Что это значит?

**A2:** Эта ошибка возникает, когда вы пытаетесь выполнить операцию (`insert`, `insertMany`, `update`, `updateMany`), которая приведет к нарушению уникальности значения в поле, для которого создан уникальный индекс.

*   **Решение:**
    1.  **Проверьте данные:** Убедитесь, что значение, которое вы пытаетесь вставить или на которое пытаетесь обновить, действительно уникально для этого поля в коллекции.
    2.  **Логика приложения:** Возможно, вам нужно добавить проверку на существование такого значения перед выполнением операции записи.
        ```javascript
        const existingDoc = await usersCollection.findOneByIndexedValue('email', newUser.email);
        if (existingDoc) {
          console.error(`Пользователь с email ${newUser.email} уже существует!`);
        } else {
          await usersCollection.insert(newUser);
        }
        ```
    3.  **Тип индекса:** Если это поле не должно быть строго уникальным, возможно, вам следует удалить уникальный индекс и создать вместо него стандартный (неуникальный) индекс, или не создавать индекс вовсе, если поиск по нему не частый.

### Q3: Как посмотреть содержимое базы данных вручную (файлы на диске)?

**A3:** Данные WiseJSON DB хранятся в файловой системе в директории, которую вы указали при создании экземпляра `WiseJSON`. Для каждой коллекции создается своя поддиректория.

*   **Путь к коллекции:** ` <dbPath>/<collectionName>/ `
*   **Чекпоинты (основные данные):** ` <dbPath>/<collectionName>/_checkpoints/ `
    *   В этой директории хранятся файлы чекпоинтов. Каждый чекпоинт состоит из:
        *   Одного `checkpoint_meta_<collectionName>_<timestamp>.json` файла (метаданные коллекции, включая информацию об индексах).
        *   Одного или нескольких `checkpoint_data_<collectionName>_<timestamp>_segX.json` файлов (сегменты с данными документов в формате JSON-массива).
    *   Самые свежие данные обычно находятся в файлах чекпоинта с последней временной меткой.
*   **WAL (Write-Ahead Log):** ` <dbPath>/<collectionName>/wal_<collectionName>.log `
    *   Этот файл содержит операции, которые были выполнены после последнего чекпоинта. Каждая строка — это JSON-объект, описывающий операцию.
*   **Для удобного просмотра:**
    *   Используйте веб-интерфейс **Data Explorer** (`wisejson-explorer-server`), который предоставляет GUI для просмотра коллекций и документов.
    *   Используйте CLI-утилиту **`wisejson-explorer show-collection <collectionName>`** или **`wise-json find <collectionName>`**.

### Q4: Мое приложение падает с ошибкой `EMFILE: too many open files`.

**A4:** Эта ошибка операционной системы означает, что ваш процесс открыл слишком много файловых дескрипторов. Применительно к WiseJSON DB, это может произойти, если:

1.  **Не закрываются экземпляры `WiseJSON` или коллекции:** Каждый экземпляр и коллекция удерживают файловые дескрипторы для WAL, чекпоинтов и блокировок. Если вы постоянно создаете новые экземпляры `WiseJSON` или получаете коллекции без их последующего закрытия (через `db.close()`), количество открытых файлов будет расти.
    *   **Решение:** Убедитесь, что вы используете один экземпляр `WiseJSON` на протяжении жизни приложения (или правильно управляете его жизненным циклом). Вызывайте `db.close()`, когда экземпляр больше не нужен.
2.  **Очень частые операции, создающие временные файлы:** Хотя WiseJSON DB использует атомарные операции записи через временные файлы, при экстремально высокой частоте таких операций теоретически возможно исчерпание лимита, если ОС не успевает освобождать дескрипторы. Однако, это менее вероятно, чем первая причина.
3.  **Другие части вашего приложения также активно работают с файлами.**

*   **Диагностика:** Используйте утилиты операционной системы (например, `lsof -p <PID>` в Linux/macOS) для проверки, какие файлы открыты вашим процессом.

### Q5: Как сделать бэкап базы данных WiseJSON DB?

**A5:** Поскольку WiseJSON DB является файловой базой данных, бэкап можно сделать простым копированием всей директории базы данных (`dbPath`).

*   **Рекомендации:**
    1.  **Остановите приложение (или убедитесь, что нет активных операций записи):** Это гарантирует, что все данные будут консистентны и WAL-файлы не будут в процессе изменения.
    2.  **Скопируйте всю директорию `dbPath`** в безопасное место.
    *   Если остановка приложения невозможна, вызовите `await db.flushToDisk()` для всех активных коллекций или `await db.close()` (если это допустимо) перед копированием, чтобы минимизировать количество операций в WAL, которые не попали в последний чекпоинт. Однако, копирование "живой" базы без остановки записи не гарантирует 100% консистентности на момент копирования, хотя механизм восстановления из WAL обычно справляется с этим при восстановлении из такого бэкапа.

### Q6: Что делать, если WAL-файл или файл чекпоинта поврежден?

**A6:** WiseJSON DB имеет механизмы для работы с такими ситуациями:

*   **Поврежденный WAL-файл:**
    *   При инициализации коллекции, если парсинг строки WAL не удается, по умолчанию (с `walReadOptions: { recover: false, strict: false }`) эта строка будет пропущена с выводом предупреждения в консоль, и WiseJSON DB попытается продолжить загрузку.
    *   Вы можете установить опцию `walReadOptions: { recover: true }` при создании экземпляра `WiseJSON`, чтобы более агрессивно пытаться восстановить данные, пропуская битые строки.
    *   Если WAL сильно поврежден, вы можете потерять операции, совершенные после последнего успешного чекпоинта.
*   **Поврежденный файл чекпоинта:**
    *   Если файл метаданных чекпоинта (`checkpoint_meta_...json`) или один из его сегментов данных (`checkpoint_data_..._segX.json`) поврежден (например, невалидный JSON), WiseJSON DB при загрузке попытается его проигнорировать (с выводом предупреждения) и загрузить предыдущий доступный (неповрежденный) чекпоинт, если он есть.
    *   Если самый последний чекпоинт поврежден, а предыдущего нет, коллекция может инициализироваться как пустая (или только с данными из WAL, если он применялся к пустому состоянию).
*   **Восстановление из бэкапа:** Если повреждение серьезное, лучшим решением будет восстановление из последней резервной копии.

### Q7: Есть ли ограничения на размер документа или коллекции?

**A7:**
*   **Размер документа:** Теоретически, размер одного JSON-документа ограничен доступной оперативной памятью Node.js (V8) для его сериализации/десериализации и обработки. Практически, очень большие документы (много мегабайт) могут быть неэффективны для хранения и обработки. Рекомендуется держать документы в разумных пределах.
*   **Размер коллекции:** Общий размер коллекции (суммарный размер всех ее документов и индексов) ограничен доступным дисковым пространством. WiseJSON DB использует сегментированные чекпоинты для эффективной работы с большими коллекциями, разбивая данные на более мелкие файлы при сохранении.
*   **Количество документов:** Ограничено в основном производительностью и доступными ресурсами (память для хранения в Map, дисковое пространство). На очень больших количествах документов (миллионы) производительность операций без индексов или со сложными `find` предикатами может снижаться.

### Q8: Можно ли использовать WiseJSON DB в нескольких процессах одновременно?

**A8:** Да, WiseJSON DB использует библиотеку `proper-lockfile` для обеспечения безопасности при доступе к файлам базы данных из нескольких **разных процессов Node.js**, запущенных на одной машине и работающих с одной и той же директорией БД. Это предотвращает гонки данных и повреждение файлов.

*   Каждая операция записи (insert, update, remove, clear, создание/удаление индекса, flushToDisk) на уровне коллекции захватывает эксклюзивную блокировку на директорию коллекции на время выполнения операции. Если другой процесс пытается выполнить операцию записи в ту же коллекцию, он будет ожидать освобождения блокировки.
*   Операции чтения обычно не требуют таких строгих блокировок и могут выполняться параллельно более эффективно, но они всегда будут читать консистентное состояние, зафиксированное последней операцией записи.

### Q9: Как WiseJSON DB обеспечивает ACID-свойства для транзакций?

**A9:** WiseJSON DB стремится к ACID-свойствам следующим образом:

*   **Atomicity (Атомарность):**
    *   *На уровне одной операции:* Каждая отдельная операция (insert, update, remove) атомарна благодаря записи в WAL перед изменением данных в памяти и механизму восстановления.
    *   *На уровне транзакции (`db.beginTransaction()`):* Все операции внутри блока `txn.commit()` записываются как единый блок в WAL-файлы всех затронутых коллекций. Если запись этого блока в WAL или последующее применение к памяти прерывается, при восстановлении незавершенный транзакционный блок не будет применен, обеспечивая атомарность "все или ничего" для этого блока.
*   **Consistency (Согласованность):**
    *   Уникальные индексы помогают поддерживать согласованность данных, предотвращая дубликаты.
    *   Транзакции переводят базу данных из одного согласованного состояния в другое. Если транзакция прерывается, данные откатываются (или не применяются) к предыдущему согласованному состоянию.
*   **Isolation (Изолированность):**
    *   Операции внутри транзакции не видны другим частям приложения (или другим транзакциям) до вызова `commit()`. Это обеспечивает базовый уровень изоляции (read committed для данных вне транзакции).
    *   WiseJSON DB не реализует сложные уровни изоляции SQL (например, serializable). При одновременном доступе из нескольких процессов, файловые блокировки `proper-lockfile` на уровне директории коллекции сериализуют операции записи, обеспечивая изоляцию на уровне файловой системы.
*   **Durability (Долговечность):**
    *   После успешного завершения операции записи (или коммита транзакции) и записи данных в WAL (и, в конечном итоге, в чекпоинт), данные считаются сохраненными и переживут перезапуск приложения или сбой системы (с учетом особенностей кэширования ОС). Опция `walForceSync` (по умолчанию `false`) может влиять на строгую долговечность на уровне ОС, но обычно не требуется.

Если у вас возникли другие вопросы или проблемы, рекомендуется также проверить GitHub Issues проекта на предмет похожих ситуаций или создать новый issue с подробным описанием проблемы.