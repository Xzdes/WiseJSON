# WiseJSON (Архитектура v2: In-Memory First с WAL и Чекпоинтами)

WiseJSON - это легковесная встраиваемая база данных на основе JSON-файлов для среды Node.js. Данная версия реализует архитектуру **In-Memory First** с использованием **журнала упреждающей записи (WAL)** и механизма **чекпоинтов** для достижения высокой производительности операций чтения и повышенной отказоустойчивости данных.

Она ориентирована на проекты, где требуется быстрое локальное хранилище данных с надежной записью без необходимости установки, настройки и администрирования внешних СУБД.

## Ключевые принципы архитектуры

*   **In-Memory First:** Все активные данные каждой коллекции хранятся в оперативной памяти, обеспечивая максимальную скорость для операций чтения.
*   **Write-Ahead Logging (WAL):** Каждая операция, изменяющая данные, сначала записывается в файл журнала (WAL). Это гарантирует, что даже при внезапном сбое системы или приложения, операции не будут потеряны и могут быть восстановлены.
*   **Checkpoints (Контрольные точки):** Периодически или по достижении определенных условий, текущее состояние данных из оперативной памяти полностью сохраняется на диск в виде файлов чекпоинта. Это позволяет уменьшить размер WAL-файла и ускорить процесс восстановления при следующем запуске.
*   **Надежность и автоматическое восстановление:** При запуске, WiseJSON автоматически восстанавливает свое последнее консистентное состояние. Для этого она загружает данные из самого свежего валидного чекпоинта и затем применяет все последующие операции из WAL-файла.
*   **Последовательное выполнение операций записи:** Для обеспечения консистентности данных, все операции, изменяющие данные одной коллекции (`insert`, `update`, `remove`, `upsert`, `clear`), а также операции создания чекпоинта, выполняются строго последовательно через внутреннюю очередь для этой коллекции.

## Основные возможности

*   **Высокопроизводительное чтение:** Благодаря хранению данных в оперативной памяти, операции чтения (`getById`, `find`, `findOne`, `getAll`, `count`) выполняются с минимальной задержкой.
*   **Отказоустойчивая запись данных:** Использование WAL и чекпоинтов значительно повышает устойчивость к потере данных при неожиданных сбоях.
*   **Автоматическое восстановление данных:** Система автоматически восстанавливает последнее согласованное состояние при старте.
*   **Гибкое управление чекпоинтами:** Настройка автоматического создания чекпоинтов по интервалу времени или по количеству записей в WAL. Возможность принудительного сохранения состояния через `collection.save()`.
*   **Контроль над хранением чекпоинтов:** Опция для указания количества последних чекпоинтов, которые необходимо хранить (`checkpointsToKeep`).
*   **Интуитивно понятный асинхронный API:** Простые в использовании методы для всех стандартных CRUD-операций, а также для получения статистики и управления коллекцией.
*   **Минимальные внешние зависимости:** WiseJSON написана на чистом JavaScript (CommonJS) и использует только встроенные модули Node.js (`fs/promises`, `path`) и, по умолчанию, пакет `uuid` для генерации уникальных идентификаторов документов.
*   **Широкие возможности конфигурации:** Позволяет настраивать параметры WAL (например, принудительная синхронизация с диском), чекпоинтов, форматирование JSON и функцию генерации ID.
*   **Система событий (хуков):** Поддержка подписки на события жизненного цикла документов (`afterInsert`, `afterUpdate`, `afterRemove`, `afterClear`) для расширения функциональности.

## Установка

1.  **Скопируйте файлы библиотеки:**
    Поместите директорию `wise-json` (которая должна содержать файлы `index.js`, `collection.js`, `wal-manager.js`, `checkpoint-manager.js`, `storage-utils.js`) в структуру вашего проекта (например, в `lib/wise-json/`).

2.  **Установите зависимость `uuid`:**
    WiseJSON использует `uuid` для генерации `_id` по умолчанию. Если `uuid` еще не установлен в вашем проекте:
    ```bash
    npm install uuid
    ```
    Или с использованием yarn:
    ```bash
    yarn add uuid
    ```

## Использование

### 1. Инициализация WiseJSON

```javascript
// main.js или app.js
const path = require('path');
const WiseJSON = require('./path/to/your/wise-json/index.js'); // Укажите правильный путь

const dbStoragePath = path.resolve(__dirname, 'application_data');

// Глобальные опции для WiseJSON (будут наследоваться коллекциями)
const dbOptions = {
    jsonIndent: 2,                   // Отступ для JSON в файлах чекпоинтов (2 пробела)
    checkpointIntervalMs: 10 * 60 * 1000, // Авто-чекпоинт каждые 10 минут (по умолчанию 5 мин)
    maxWalEntriesBeforeCheckpoint: 2000, // Авто-чекпоинт после 2000 записей в WAL (по умолчанию 1000)
    walForceSync: false,             // false для лучшей производительности (по умолчанию). Установите true для максимальной надежности записи WAL.
    checkpointsToKeep: 3,            // Хранить 3 последних чекпоинта (по умолчанию 2).
    // maxSegmentSizeBytes: 2 * 1024 * 1024, // Макс. размер сегмента данных в чекпоинте (по умолчанию 1MB)
    // idGenerator: () => `my-custom-id-${Date.now()}-${Math.random()}` // Пример кастомного генератора ID
};

const db = new WiseJSON(dbStoragePath, dbOptions);

// db.baseDirInitPromise разрешается, когда базовая директория БД готова.
// Однако, полная инициализация коллекции (включая загрузку данных) происходит асинхронно
// при первом вызове db.collection(). Промис этой инициализации (collection.initPromise)
// неявно ожидается всеми публичными методами коллекции.
db.baseDirInitPromise
    .then(() => {
        console.log('WiseJSON: Базовая директория хранилища готова.');
        // Можно начинать работу с коллекциями
        initializeAppLogic();
    })
    .catch(baseDirError => {
        console.error('WiseJSON: КРИТИЧЕСКАЯ ОШИБКА при инициализации базовой директории!', baseDirError);
        process.exit(1); // Важно завершить приложение, если БД не может стартовать
    });

async function initializeAppLogic() {
    let productsCollection;
    try {
        console.log("Получение/создание коллекции 'products'...");
        productsCollection = await db.collection('products', {
            // Опции, специфичные для этой коллекции, переопределят глобальные
            // checkpointIntervalMs: 1 * 60 * 1000 // Например, для продуктов чекпоинт чаще
        });
        
        // После этого вызова, productsCollection.initPromise уже должен быть разрешен,
        // и коллекция готова к работе. Публичные методы сами ожидают _ensureInitialized.
        console.log(`Коллекция 'products' готова. Начальное количество документов: ${await productsCollection.count()}`);
        
        // Пример использования:
        // await productsCollection.insert({ name: 'Super Laptop', price: 1200 });
        // const allProducts = await productsCollection.getAll();
        // console.log('Все продукты:', allProducts);

    } catch (collectionError) {
        console.error(`WiseJSON: Ошибка при работе с коллекцией 'products':`, collectionError);
    } finally {
        // Важно корректно закрывать базу данных при завершении работы приложения
        if (db) {
            console.log("Завершение работы приложения, закрытие WiseJSON...");
            await db.close()
                .then(() => console.log("WiseJSON успешно закрыта."))
                .catch(closeErr => console.error("Ошибка при закрытии WiseJSON:", closeErr));
        }
    }
}
```

### 2. API Коллекции (`Collection`)

Все публичные методы экземпляра `Collection` являются асинхронными и возвращают `Promise`. Они автоматически ожидают завершения инициализации коллекции перед выполнением.

*   `async collection.insert(dataObject)`: Вставляет новый документ.
*   `async collection.getById(id)`: Находит документ по `_id`.
*   `async collection.find(queryFunction)`: Находит все документы, соответствующие предикату.
*   `async collection.findOne(queryFunction)`: Находит первый документ, соответствующий предикату.
*   `async collection.getAll()`: Получает все документы из коллекции.
*   `async collection.update(id, updatesObject)`: Обновляет документ с указанным `_id`.
*   `async collection.remove(id)`: Удаляет документ с указанным `_id`. Возвращает `true` если удален, `false` если не найден.
*   `async collection.count([queryFunction])`: Подсчитывает количество документов.
*   `async collection.upsert(query, dataToUpsert, [upsertOptions])`: Обновляет документ, если найден по `query`, иначе вставляет новый.
*   `async collection.clear()`: Удаляет все документы из коллекции.
*   `async collection.getCollectionStats()`: Возвращает объект со статистикой по коллекции (количество документов, информация о WAL и последнем чекпоинте, опции).
*   `async collection.save()`: Принудительно инициирует создание чекпоинта для коллекции, сохраняя текущее состояние данных из памяти на диск.
*   `collection.on(eventName, listenerFunction)`: Подписывает слушателя на событие.
*   `collection.off(eventName, [listenerFunction])`: Отписывает слушателя.

**Поддерживаемые события:** `'afterInsert'`, `'afterUpdate'`, `'afterRemove'`, `'afterClear'`.

### 3. Завершение работы и сохранение данных

Для гарантии сохранения всех данных, важно корректно закрывать базу данных перед завершением работы вашего приложения. Метод `db.close()` обеспечивает выполнение финальных чекпоинтов для всех активных коллекций.

```javascript
// При graceful shutdown вашего приложения:
async function shutdown() {
    if (db) {
        console.log('WiseJSON: Выполняется закрытие базы данных...');
        await db.close();
        console.log('WiseJSON: База данных закрыта.');
    }
    process.exit(0);
}

process.on('SIGINT', shutdown); // Ctrl+C
process.on('SIGTERM', shutdown); // Сигнал завершения
```

## Архитектура и Надежность (Детали)

WiseJSON v2 построена на следующих принципах для обеспечения скорости и сохранности данных:

*   **Данные в Памяти (In-Memory First):**
    *   При инициализации, каждая коллекция загружает свои данные из последнего валидного чекпоинта и применяет к ним все последующие операции из WAL-файла. Эти данные полностью размещаются в оперативной памяти (`Map` объектов).
    *   Все операции чтения (например, `find`, `getById`) выполняются напрямую по данным в памяти, что делает их очень быстрыми.

*   **Журнал Упреждающей Записи (Write-Ahead Log - WAL):**
    *   Каждая операция, изменяющая данные (`insert`, `update`, `remove`, `clear`, `upsert`), сначала сериализуется и **атомарно дописывается в конец специального WAL-файла** (`<collectionName>.wal.jsonl`). Каждая запись в WAL содержит тип операции, данные и временную метку.
    *   Только после успешной записи в WAL операция применяется к данным в оперативной памяти.
    *   Это гарантирует, что если приложение или система неожиданно завершит работу до того, как данные из памяти будут сохранены в чекпоинт, эти операции не будут потеряны и будут восстановлены из WAL при следующем запуске.
    *   Опция `walForceSync: true` заставляет каждую запись в WAL немедленно сбрасываться на физический диск, что максимизирует надежность, но может замедлить операции записи. По умолчанию (`false`) используется буферизация ОС.

*   **Чекпоинты (Контрольные точки):**
    *   Чекпоинт — это процесс сохранения полного текущего состояния всех документов коллекции из оперативной памяти на диск. Данные сохраняются в один или несколько файлов-сегментов (если общий объем данных превышает `options.maxSegmentSizeBytes`).
    *   Каждый чекпоинт сопровождается мета-файлом, который содержит временную метку чекпоинта и список его файлов-сегментов. "Публикация" чекпоинта (делающая его видимым для загрузки) происходит через атомарное переименование временного мета-файла в финальный.
    *   После успешного создания чекпоинта, записи из WAL-файла, которые старше или равны временной метке этого чекпоинта, удаляются из WAL (или WAL усекается/ротируется). Записи, пришедшие в WAL *во время* выполнения чекпоинта, сохраняются.
    *   Чекпоинты выполняются:
        1.  Автоматически по истечении интервала времени (задается опцией `checkpointIntervalMs`).
        2.  Автоматически при достижении определенного количества новых записей в WAL с момента последнего чекпоинта (опция `maxWalEntriesBeforeCheckpoint`).
        3.  Принудительно по вызову метода `collection.save()`.
        4.  Автоматически при корректном закрытии коллекции или всей базы данных через `collection.close()` или `db.close()`.
    *   Система хранит ограниченное количество последних чекпоинтов (настраивается через `options.checkpointsToKeep`), автоматически удаляя более старые.

*   **Процесс Восстановления:**
    1.  При запуске (инициализации коллекции) WiseJSON ищет самый последний *валидный* мета-файл чекпоинта в директории `_checkpoints`. Валидность определяется наличием самого мета-файла и всех файлов-сегментов данных, на которые он ссылается.
    2.  Если валидный чекпоинт найден, данные из его сегментов загружаются в оперативную память.
    3.  Затем читается WAL-файл. Все операции из WAL, временная метка которых *строго новее* временной метки загруженного чекпоинта, последовательно применяются к данным в памяти.
    4.  Если валидных чекпоинтов не найдено, но существует WAL-файл, система пытается восстановить состояние, применяя все операции из WAL к пустому набору данных.
    5.  Если нет ни чекпоинтов, ни WAL, коллекция считается новой или пустой.

## Модель параллелизма

*   **Операции записи (изменяющие данные):** Выполняются **строго последовательно** для каждой коллекции через внутреннюю очередь. Это включает `insert`, `update`, `remove`, `upsert`, `clear`, а также внутренние операции, такие как создание чекпоинта (`_performCheckpoint`). Это гарантирует консистентность на всех уровнях (WAL, память, чекпоинты).
*   **Операции чтения:** Выполняются напрямую с данными в памяти и **не блокируются** операциями записи (и не блокируют их, кроме как на очень короткое время на уровне структур данных JavaScript, если таковое имеется). Чтение видит актуальное состояние данных в памяти на момент начала операции.

## Структура хранения данных (для каждой коллекции)

Внутри директории каждой коллекции (например, `dbRootPath/myCollection/`):

*   **`myCollection.wal.jsonl`**: Файл журнала упреждающей записи. Каждая строка – это JSON-объект, описывающий операцию.
*   **`_checkpoints/`**: Поддиректория, содержащая файлы чекпоинтов.
    *   **`checkpoint_meta_myCollection_YYYY-MM-DDTHH-MM-SS-MSZ.json`**: Мета-файл для каждого чекпоинта. Содержит временную метку, имя коллекции, список файлов-сегментов данных этого чекпоинта и общее количество документов.
    *   **`checkpoint_data_myCollection_YYYY-MM-DDTHH-MM-SS-MSZ_segN.json`**: Один или несколько файлов-сегментов данных для каждого чекпоинта. Содержат массив документов в формате JSON.

## Опции конфигурации (Детально)

Опции могут быть переданы в конструктор `WiseJSON` (глобальные) или в метод `db.collection()` (специфичные для коллекции).

*   `jsonIndent: number | null` (по умолчанию: `2`)
    Отступ для форматирования JSON в файлах чекпоинтов. Установите `null` или `0` для компактного JSON без отступов.
*   `idGenerator: () => string` (по умолчанию: `uuidv4`)
    Функция, которая будет вызываться для генерации уникального `_id` для новых документов, если `_id` не предоставлен явно.
*   `maxSegmentSizeBytes: number` (по умолчанию: `1048576` (1MB))
    Максимальный размер одного файла-сегмента данных внутри чекпоинта. Если общий объем данных чекпоинта превышает это значение, он будет разбит на несколько файлов-сегментов.
*   `checkpointIntervalMs: number` (по умолчанию: `300000` (5 минут))
    Интервал в миллисекундах для автоматического создания чекпоинтов. Если установлено `0` или `Infinity`, автоматические чекпоинты по времени будут отключены.
*   `maxWalEntriesBeforeCheckpoint: number` (по умолчанию: `1000`)
    Максимальное количество записей, добавленных в WAL с момента последнего чекпоинта. При достижении этого лимита будет инициирован автоматический чекпоинт. Если установлено `0` или `Infinity`, эта проверка будет отключена.
*   `walForceSync: boolean` (по умолчанию: `false`)
    Если `true`, после каждой записи операции в WAL-файл будет вызываться `fs.sync()` для файлового дескриптора. Это гарантирует, что данные немедленно сброшены на физический диск, повышая надежность при сбоях питания или ОС. Однако это может значительно снизить производительность операций записи. Используйте `true` только для критически важных данных, где потеря даже нескольких последних операций недопустима.
*   `checkpointsToKeep: number` (по умолчанию: `2`)
    Количество последних полных чекпоинтов, которые будут сохранены на диске. Более старые чекпоинты (вместе с их файлами данных и мета-файлами) будут автоматически удаляться после создания нового успешного чекпоинта. Минимальное значение - `1`.

## Обработка ошибок

*   Все публичные асинхронные методы возвращают Промисы. В случае ошибки (проблемы с файловой системой, ошибки парсинга JSON, неверные аргументы методов и т.д.), Промис будет отклонен (`rejected`) с объектом `Error`. Сообщения об ошибках обычно содержат префикс `WiseJSON:`, `Collection ('collectionName'):`, `WalManager:` или `CheckpointManager:` для облегчения отладки.
*   Критическая ошибка при инициализации базовой директории `dbRootPath` приведет к отклонению `db.baseDirInitPromise`.
*   Критическая ошибка при инициализации конкретной коллекции (например, невозможность прочитать чекпоинт или WAL) приведет к отклонению промиса, возвращаемого `db.collection('name')` (или `collection.initPromise` для этого экземпляра). Все последующие вызовы методов этой коллекции также будут завершаться ошибкой через `_ensureInitialized()`.
*   Ошибки внутри пользовательских функций-слушателей событий (`collection.on(...)`) логируются в консоль, но не прерывают выполнение основной операции и не отклоняют ее промис.

## Тестирование

Проект включает тестовый файл (например, `test/full-test-wise-json.js`), который демонстрирует использование и проверяет основной функционал, включая восстановление, работу WAL и чекпоинтов. Для запуска тестов выполните:
```bash
node path/to/your/test/full-test-wise-json.js
```

## Ограничения и Рекомендации

*   **Требования к памяти:** Так как WiseJSON работает по принципу In-Memory First, все данные активных коллекций должны помещаться в доступную оперативную память процесса Node.js. Для очень больших наборов данных, превышающих объем ОЗУ, эта СУБД может не подойти.
*   **Транзакции между коллекциями:** WiseJSON **не предоставляет** встроенных механизмов для атомарных транзакций, охватывающих несколько коллекций.
*   **Сложные запросы и индексация:** В текущей версии отсутствуют сложные языки запросов (кроме фильтрации функцией-предикатом) и пользовательские индексы для полей (кроме внутреннего хранения в `Map` по `_id`). Поиск по полям, отличным от `_id`, выполняется полным перебором документов в памяти, что очень быстро для данных, помещающихся в ОЗУ, но может быть неоптимально для некоторых паттернов запросов на больших коллекциях.
*   **Одновременный доступ из нескольких процессов Node.js:** WiseJSON **категорически не предназначена** для одновременной записи в одну и ту же базу данных (`dbRootPath`) из нескольких независимых процессов Node.js. Это приведет к повреждению данных (WAL и файлов чекпоинтов). Библиотека рассчитана на использование в рамках одного процесса Node.js (где множество асинхронных операций обрабатываются корректно благодаря внутренней очереди).
*   **Резервное копирование:** Несмотря на механизмы WAL и чекпоинтов, которые обеспечивают восстановление после сбоев, **регулярное создание полных резервных копий** всей директории `dbRootPath` на внешний носитель или в облако является стандартной и настоятельно рекомендуемой практикой для защиты от сбоев оборудования, ошибок пользователя или других катастрофических событий.


## Лицензия

MIT License

Copyright (c) 2025 Guliaev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.