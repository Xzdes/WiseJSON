# WiseJSON v2 (Архитектура In-Memory First)

WiseJSON - это легковесная встраиваемая база данных на основе JSON-файлов для Node.js, переработанная для обеспечения высокой производительности операций чтения и повышенной отказоустойчивости. Она использует архитектуру **In-Memory First**, **журнал упреждающей записи (WAL)** и механизм **чекпоинтов**.

WiseJSON ориентирована на проекты, где требуется быстрое локальное хранилище данных с надежной записью без необходимости администрирования внешних СУБД.

## Ключевые принципы новой архитектуры

*   **In-Memory First:** Все активные данные коллекции хранятся в оперативной памяти для максимальной скорости чтения.
*   **Write-Ahead Logging (WAL):** Все операции изменения данных сначала записываются в файл журнала (WAL) перед применением к данным в памяти. Это гарантирует, что при сбое операции не будут потеряны.
*   **Checkpoints (Контрольные точки):** Периодически (или по триггеру) текущее состояние данных из памяти сохраняется на диск в виде файлов чекпоинта. Это позволяет уменьшить размер WAL и ускорить восстановление.
*   **Надежность и восстановление:** При запуске, WiseJSON восстанавливает свое состояние, загружая последний валидный чекпоинт и "накатывая" на него все последующие операции из WAL.
*   **Атомарность операций на уровне коллекции:** Операции изменения данных (`insert`, `update`, `remove`, `upsert`, `clear`) выполняются последовательно через внутреннюю очередь для каждой коллекции.

## Основные возможности

*   **Высокопроизводительное чтение:** Благодаря хранению данных в оперативной памяти, операции чтения (`getById`, `find`, `findOne`, `getAll`, `count`) выполняются очень быстро.
*   **Надежная запись данных:** Использование WAL и чекпоинтов значительно повышает устойчивость к потерям данных при сбоях.
*   **Автоматическое восстановление:** При старте система автоматически восстанавливает последнее консистентное состояние.
*   **Управляемые чекпоинты:** Возможность настроить интервал и условия для создания чекпоинтов, а также выполнить чекпоинт вручную (`collection.save()`).
*   **Гибкий асинхронный API:** Интуитивно понятные методы для CRUD-операций, статистики и управления коллекцией.
*   **Минимальные зависимости:** Использует только встроенные модули Node.js (`fs/promises`, `path`) и `uuid` (для ID по умолчанию).
*   **Настраиваемость:** Широкий набор опций для управления поведением WAL, чекпоинтов, генерации ID и форматирования JSON.
*   **Система хуков (событий):** Простой механизм подписки на события жизненного цикла документов (`afterInsert`, `afterUpdate`, `afterRemove`, `afterClear`).

## Установка

1.  **Скопируйте библиотеку:**
    Поместите директорию `wise-json` (содержащую `index.js`, `collection.js`, `wal-manager.js`, `checkpoint-manager.js`, `storage-utils.js`) в структуру вашего проекта.
    *Примечание: WiseJSON на данный момент не распространяется как готовый npm-пакет с автоматической установкой зависимостей, а предназначена для прямого включения в проект.*

2.  **Установите зависимость `uuid`:**
    Если она еще не установлена в вашем проекте, выполните:
    ```bash
    npm install uuid
    ```
    или если вы используете yarn:
    ```bash
    yarn add uuid
    ```

## Использование

### 1. Инициализация WiseJSON

```javascript
const WiseJSON = require('./path/to/wise-json/index.js'); // Укажите корректный путь
const path = require('path');

const dbStoragePath = path.resolve(__dirname, 'my_application_database');

// Опции для WiseJSON (будут наследоваться коллекциями)
const dbOptions = {
    jsonIndent: 2, // Отступ для файлов чекпоинтов
    // Опции для WAL и чекпоинтов:
    checkpointIntervalMs: 5 * 60 * 1000, // Авто-чекпоинт каждые 5 минут (0 для отключения)
    maxWalEntriesBeforeCheckpoint: 1000, // Авто-чекпоинт после 1000 записей в WAL (0 для отключения)
    walForceSync: false, // true для макс. надежности WAL (медленнее), false для производительности
    checkpointsToKeep: 3, // Хранить 3 последних чекпоинта
    // maxSegmentSizeBytes: 1 * 1024 * 1024, // Макс. размер сегмента данных в чекпоинте
    // idGenerator: () => `custom-${Date.now()}` // Кастомный генератор ID
};

const db = new WiseJSON(dbStoragePath, dbOptions);

db.baseDirInitPromise
    .then(() => {
        console.log('WiseJSON: Базовая директория готова.');
        // Теперь можно получать коллекции и работать с ними
        startApplication();
    })
    .catch(initializationError => {
        console.error('WiseJSON: КРИТИЧЕСКАЯ ОШИБКА при инициализации базовой директории!', initializationError);
        process.exit(1);
    });

async function startApplication() {
    let usersCollection;
    try {
        usersCollection = await db.collection('users', {
            // Опции специфичные для этой коллекции, переопределяют глобальные
            // checkpointIntervalMs: 1 * 60 * 1000 // Например, для пользователей чекпоинт чаще
        });
        
        // Дожидаемся полной инициализации коллекции (загрузка из чекпоинта/WAL)
        // initPromise теперь внутренний, _ensureInitialized вызывается методами коллекции
        // Публичные методы коллекции уже содержат await this._ensureInitialized();

        console.log(`Коллекция 'users' готова. Документов: ${await usersCollection.count()}`);
        
        // ... ваша логика приложения ...

    } catch (collectionError) {
        console.error(`WiseJSON: Ошибка при работе с коллекцией 'users':`, collectionError);
    } finally {
        // Важно корректно закрывать базу данных при завершении работы приложения
        if (db) {
            console.log("Завершение работы, закрытие WiseJSON...");
            await db.close()
                .then(() => console.log("WiseJSON успешно закрыта."))
                .catch(closeErr => console.error("Ошибка при закрытии WiseJSON:", closeErr));
        }
    }
}
```

### 2. API Коллекции (`Collection`)

Экземпляр `Collection` предоставляет следующие асинхронные методы:

*   `async collection.insert(dataObject)`: Вставляет новый документ.
*   `async collection.getById(id)`: Находит документ по `_id`.
*   `async collection.find(queryFunction)`: Находит все документы, удовлетворяющие `queryFunction`.
*   `async collection.findOne(queryFunction)`: Находит первый документ, удовлетворяющий `queryFunction`.
*   `async collection.getAll()`: Получает все документы из коллекции.
*   `async collection.update(id, updatesObject)`: Обновляет документ.
*   `async collection.remove(id)`: Удаляет документ.
*   `async collection.count([queryFunction])`: Подсчитывает количество документов.
*   `async collection.upsert(query, dataToUpsert, [options])`: Обновляет или вставляет документ.
*   `async collection.clear()`: Удаляет все документы из коллекции.
*   `async collection.getCollectionStats()`: Возвращает статистику по коллекции.
*   `async collection.save()`: Принудительно выполняет чекпоинт (сохраняет данные из памяти на диск).
*   `async collection.close()`: Корректно закрывает коллекцию, выполняя финальный чекпоинт. (Обычно вызывается через `db.close()`).
*   `collection.on(eventName, listener)`: Подписывает на событие.
*   `collection.off(eventName, [listener])`: Отписывает от события.

**Примеры использования методов аналогичны предыдущей версии README, но теперь все операции чтения происходят из памяти, а операции записи используют WAL.**

### 3. Завершение работы

Крайне важно корректно завершать работу с базой данных, чтобы все данные были сохранены на диск (через финальный чекпоинт) и ресурсы были освобождены.

```javascript
// ... в конце работы вашего приложения
if (db) {
    await db.close();
}
```

## Архитектура и Надежность

WiseJSON версии 2 использует архитектуру "In-Memory First" для достижения высокой производительности и надежности.

*   **In-Memory First:**
    *   При инициализации коллекции все ее данные загружаются из последнего чекпоинта и последующих записей WAL в оперативную память.
    *   Все операции чтения (`getById`, `find` и т.д.) выполняются непосредственно с данными в памяти, что обеспечивает очень низкую задержку.

*   **Write-Ahead Log (WAL):**
    *   Каждая операция, изменяющая данные (`insert`, `update`, `remove`, `clear`, `upsert`), сначала записывается как отдельная запись в специальный файл журнала (`<collectionName>.wal.jsonl`).
    *   Запись в WAL происходит до применения изменений к данным в памяти.
    *   Это гарантирует, что в случае внезапного сбоя или перезапуска приложения, незавершенные операции или операции, еще не попавшие в чекпоинт, могут быть восстановлены из WAL.
    *   Опция `walForceSync: true` позволяет форсировать сброс каждой записи WAL на физический диск, обеспечивая максимальную надежность ценой производительности записи.

*   **Checkpoints (Контрольные точки):**
    *   Чекпоинт — это процесс сохранения текущего состояния всех данных коллекции из оперативной памяти на диск в файлы чекпоинта.
    *   После успешного создания чекпоинта, соответствующие ему записи в WAL могут быть безопасно удалены или помечены как обработанные (в текущей реализации WAL усекается).
    *   Чекпоинты выполняются:
        *   Автоматически по истечении интервала (`options.checkpointIntervalMs`).
        *   Автоматически при достижении определенного количества записей в WAL (`options.maxWalEntriesBeforeCheckpoint`).
        *   Принудительно по вызову `collection.save()`.
        *   При корректном закрытии коллекции/базы данных (`collection.close()` или `db.close()`).
    *   Хранится ограниченное количество последних чекпоинтов (`options.checkpointsToKeep`), старые автоматически удаляются.

*   **Восстановление:**
    1.  При запуске, `Collection` сначала ищет самый последний валидный мета-файл чекпоинта.
    2.  Данные из файлов сегментов этого чекпоинта загружаются в память.
    3.  Затем читается WAL-файл, и все операции, временная метка которых новее временной метки загруженного чекпоинта, последовательно применяются к данным в памяти.
    4.  Если валидных чекпоинтов нет, восстановление происходит только на основе WAL-файла (если он существует).

## Модель параллелизма и обработка запросов

*   **Операции записи (модификации данных):**
    *   Все операции, изменяющие данные (`insert`, `update`, `remove`, `upsert`, `clear`), а также внутренние операции, такие как создание чекпоинта (`save`), помещаются во внутреннюю очередь для каждой коллекции.
    *   Эти операции выполняются **строго последовательно** в рамках одной коллекции. Это гарантирует консистентность данных в WAL, в памяти и при записи чекпоинтов.

*   **Операции чтения:**
    *   Операции чтения (`getAll`, `find`, `findOne`, `getById`, `count`, `getCollectionStats`) выполняются с текущим состоянием данных в оперативной памяти и **не используют очередь записи**.
    *   Они могут выполняться параллельно друг с другом и с операциями записи (которые ожидают своей очереди или выполняются).
    *   Чтение всегда видит данные, которые были зафиксированы в памяти на момент начала операции чтения (близко к уровню изоляции "Read Committed" по отношению к данным в памяти).

## Структура хранения данных

Для каждой коллекции в ее директории (`dbRootPath/collectionName/`) создаются:

*   **`collectionName.wal.jsonl`**: Файл журнала упреждающей записи. Содержит операции изменения данных в формате JSON Lines.
*   **`_checkpoints/`**: Поддиректория, содержащая файлы чекпоинтов.
    *   **`checkpoint_meta_collectionName_TIMESTAMP.json`**: Мета-файл для каждого чекпоинта. Содержит временную метку, список файлов-сегментов данных и другую служебную информацию.
    *   **`checkpoint_data_collectionName_TIMESTAMP_segN.json`**: Один или несколько файлов-сегментов, содержащих фактические данные документов в формате JSON-массива для данного чекпоинта.

## Опции конфигурации

Опции могут быть заданы глобально при создании экземпляра `WiseJSON` или специфично для каждой коллекции при ее получении через `db.collection()`. Опции коллекции имеют приоритет.

*   `jsonIndent` (number | null, по умолчанию: `2`): Отступ для JSON в файлах чекпоинтов. `null` или `0` для компактного вывода.
*   `idGenerator` (function, по умолчанию: `uuidv4`): Функция для генерации уникальных `_id` документов.
*   `maxSegmentSizeBytes` (number, по умолчанию: `1MB`): Максимальный размер одного файла-сегмента данных внутри чекпоинта. Если чекпоинт больше, он будет разбит на несколько сегментов.
*   `checkpointIntervalMs` (number, по умолчанию: `300000` (5 минут)): Интервал в миллисекундах для автоматического создания чекпоинтов. Установите `0` или `Infinity` для отключения автоматических чекпоинтов по времени.
*   `maxWalEntriesBeforeCheckpoint` (number, по умолчанию: `1000`): Максимальное количество записей в WAL с момента последнего чекпоинта, после которого будет инициирован автоматический чекпоинт. Установите `0` или `Infinity` для отключения этой проверки.
*   `walForceSync` (boolean, по умолчанию: `false`): Если `true`, каждая запись в WAL будет принудительно синхронизирована с диском (через `fs.sync()` для дескриптора файла). Это обеспечивает максимальную надежность при сбоях питания, но может значительно снизить производительность операций записи. Рекомендуется для критически важных данных.
*   `checkpointsToKeep` (number, по умолчанию: `2`): Количество последних полных чекпоинтов, которые нужно хранить. Старые чекпоинты будут автоматически удаляться. Минимальное значение - `1`.

## Обработка ошибок

*   Все асинхронные методы возвращают промисы. Ошибки (файловой системы, парсинга, неверные аргументы) приводят к отклонению промиса с объектом `Error`.
*   Критические ошибки инициализации (`db.baseDirInitPromise` или `collection.initPromise`) должны быть обработаны приложением.
*   Ошибки внутри слушателей событий логируются, но не прерывают основную операцию.

## Тестирование

Смотрите пример файла `test/full-test-wise-json.js` для комплексного тестирования функциональности.

## Ограничения и Рекомендации

*   **In-Memory:** Все данные активных коллекций хранятся в ОЗУ. Убедитесь, что у вас достаточно памяти для ваших данных.
*   **Транзакции между коллекциями:** Не поддерживаются. Атомарность гарантируется только на уровне операций одной коллекции.
*   **Одновременный доступ из нескольких процессов:** WiseJSON **не предназначена** для одновременной модификации одной и той же базы данных (`dbRootPath`) из нескольких независимых процессов Node.js. Это может привести к повреждению WAL или файлов чекпоинтов.
*   **Резервное копирование:** Несмотря на WAL и чекпоинты, рекомендуется периодически создавать полные резервные копии всей директории `dbRootPath`.
*   **Индексы:** В текущей версии полноценные пользовательские индексы для ускорения сложных запросов отсутствуют. Поиск выполняется полным перебором данных в памяти (что быстро для умеренных объемов).

## Лицензия

MIT License

Copyright (c) 2025 Guliaev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.